set(PROJECT_VERSION 1.2.6)

# Informative message at the start of configuration
message(STATUS "--- Configuring QFF Media Converter (v${PROJECT_VERSION}) ---")
message(STATUS "CMake version: ${CMAKE_VERSION}")

cmake_minimum_required(VERSION 3.16)

project(qffgui VERSION ${PROJECT_VERSION} LANGUAGES CXX)

add_definitions(-DAPP_VERSION=\"${PROJECT_VERSION}\")

set(CMAKE_AUTOUIC ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

if(MSVC)
    add_compile_options(/Zc:__cplusplus)
endif()

find_package(QT NAMES Qt6 Qt5 REQUIRED COMPONENTS Widgets LinguistTools Core5Compat)
find_package(Qt${QT_VERSION_MAJOR} REQUIRED COMPONENTS
  Widgets
  Network
  LinguistTools
  Core
  Gui
  Multimedia
  MultimediaWidgets
)

# Provide feedback on Qt version found
if(NOT Qt6_FOUND)
    message(FATAL_ERROR "Qt6 not found. Please ensure Qt6 is installed and in your CMAKE_PREFIX_PATH.")
else()
    message(STATUS "Found Qt6 version: ${Qt6_VERSION} at ${Qt6_DIR}")
endif()

# The MACOSX_BUNDLE_ICON_FILE variable is added to the Info.plist
# generated by CMake. This variable contains the .icns file name,
# without the path.
set(MACOSX_BUNDLE_ICON_FILE logo.icns)

# And the following tells CMake where to find and install the file itself.
set(app_icon_macos "${CMAKE_CURRENT_SOURCE_DIR}/icon/logo.icns")
set_source_files_properties(${app_icon_macos} PROPERTIES
       MACOSX_PACKAGE_LOCATION "Resources")


set(app_icon_resource_windows "${CMAKE_CURRENT_SOURCE_DIR}/icon/logo.ico")

set(TS_FILES qffgui_en_IN.ts)


set(PROJECT_SOURCES
        main.cpp
        mainwindow.cpp mainwindow.h mainwindow.ui
        ffmpegutils.h ffmpegutils.cpp
        ffmpegstatusdialog.h ffmpegstatusdialog.cpp
        ffmpegstatusdialog.h ffmpegstatusdialog.cpp ffmpegstatusdialog.ui
        menubarhelper.h menubarhelper.cpp
        aboutdialog.h aboutdialog.cpp
        audiowaveformwidget.h audiowaveformwidget.cpp
        updatemanager.h updatemanager.cpp
        ${TS_FILES}
)

if(${QT_VERSION_MAJOR} GREATER_EQUAL 6)
    qt_add_executable(qffgui
        MANUAL_FINALIZATION
        ${PROJECT_SOURCES}
        images.qrc
        ${app_icon_macos}
        ${app_icon_resource_windows}
        downloadprogressdialog.h downloadprogressdialog.cpp
        pythoninstaller.h pythoninstaller.cpp

    )
# Define target properties for Android with Qt 6 as:
#    set_property(TARGET qffgui APPEND PROPERTY QT_ANDROID_PACKAGE_SOURCE_DIR
#                 ${CMAKE_CURRENT_SOURCE_DIR}/android)
# For more information, see https://doc.qt.io/qt-6/qt-add-executable.html#target-creation

    qt_create_translation(QM_FILES ${CMAKE_SOURCE_DIR} ${TS_FILES})
else()
    if(ANDROID)
        add_library(qffgui SHARED
            ${PROJECT_SOURCES}
        )
# Define properties for Android with Qt 5 after find_package() calls as:
#    set(ANDROID_PACKAGE_SOURCE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/android")
    else()
        add_executable(qffgui
            ${PROJECT_SOURCES}
        )
    endif()

    qt5_create_translation(QM_FILES ${CMAKE_SOURCE_DIR} ${TS_FILES})
endif()



target_link_libraries(qffgui PRIVATE
  Qt${QT_VERSION_MAJOR}::Widgets
  Qt${QT_VERSION_MAJOR}::Network
  Qt${QT_VERSION_MAJOR}::Core
  Qt${QT_VERSION_MAJOR}::Multimedia
  Qt${QT_VERSION_MAJOR}::MultimediaWidgets
)


# Qt for iOS sets MACOSX_BUNDLE_GUI_IDENTIFIER automatically since Qt 6.1.
# If you are developing for iOS or macOS you should consider setting an
# explicit, fixed bundle identifier manually though.
if(${QT_VERSION} VERSION_LESS 6.1.0)
  set(BUNDLE_ID_OPTION MACOSX_BUNDLE_GUI_IDENTIFIER com.bitmutex.qffgui)
endif()
set_target_properties(qffgui PROPERTIES
    VERSION ${PROJECT_VERSION}
    ${BUNDLE_ID_OPTION}
    MACOSX_BUNDLE_BUNDLE_VERSION ${PROJECT_VERSION}
    MACOSX_BUNDLE_SHORT_VERSION_STRING ${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}
    MACOSX_BUNDLE TRUE
    MACOSX_BUNDLE_GUI_INFORMATIVE_ABOUT TRUE
    WIN32_EXECUTABLE TRUE
)

target_include_directories(qffgui PRIVATE ${CMAKE_CURRENT_BINARY_DIR}/qffgui_includes/include)

# Get path to QtCore binary to infer the Qt bin directory
# Get location of QtCore to find Qt's root
get_target_property(QtCoreLocation Qt${QT_VERSION_MAJOR}::Core LOCATION)
get_filename_component(QT_BIN_DIR "${QtCoreLocation}" DIRECTORY)              # /mingw_64/bin
get_filename_component(QT_HOST_DIR "${QT_BIN_DIR}" DIRECTORY)                # /mingw_64
get_filename_component(QT_VERSION_DIR "${QT_HOST_DIR}" DIRECTORY)            # /6.9.1
get_filename_component(QT_ROOT_DIR "${QT_VERSION_DIR}" DIRECTORY)            # /Qt

# Construct the paths
set(IFW_VERSION "4.10")
# --- Verify existence of required tools and directories ---

# 1. Check for binarycreator tool
if(CMAKE_SYSTEM_NAME STREQUAL "Windows")
    set(BINARYCREATOR_BIN "binarycreator.exe")
else()
    set(BINARYCREATOR_BIN "binarycreator")
endif()

find_program(BINARYCREATOR_EXE_FOUND ${BINARYCREATOR_BIN}
    PATHS "${QT_ROOT_DIR}/Tools/QtInstallerFramework/${IFW_VERSION}/bin"
    NO_DEFAULT_PATH
)

if(NOT BINARYCREATOR_EXE_FOUND)
    message(WARNING "Error: ${BINARYCREATOR_BIN} not found. Expected at ${QT_ROOT_DIR}/Tools/QtInstallerFramework/${IFW_VERSION}/bin.")
    set(BINARYCREATOR_EXE "${BINARYCREATOR_BIN}") # CI Override or fallback
else()
    set(BINARYCREATOR_EXE "${BINARYCREATOR_EXE_FOUND}")
    message(STATUS "Found ${BINARYCREATOR_BIN} at: ${BINARYCREATOR_EXE}")
endif()

# 2. Check for windeployqt.exe
if(CMAKE_SYSTEM_NAME STREQUAL "Windows")
    # 2. Check for windeployqt.exe
    find_program(WINDEPLOYQT_EXE_FOUND windeployqt PATHS "${QT_BIN_DIR}" NO_DEFAULT_PATH)
    if(NOT WINDEPLOYQT_EXE_FOUND)
        message(FATAL_ERROR "Error: windeployqt.exe not found. Expected at ${QT_BIN_DIR}. Please ensure Qt development tools are correctly installed.")
    else()
        set(WINDEPLOYQT_EXE "${WINDEPLOYQT_EXE_FOUND}") # Use the found path
        message(STATUS "Found windeployqt.exe at: ${WINDEPLOYQT_EXE}")
    endif()
else()
    # On non-Windows systems (Linux, macOS), windeployqt.exe is not relevant.
    # We can set the variable to an empty string or simply not set it.
    # An empty string is often safer if other parts of your CMake might conditionally use this variable.
    set(WINDEPLOYQT_EXE "")
    message(STATUS "windeployqt.exe check skipped, as this is not a Windows system (${CMAKE_SYSTEM_NAME}).")
endif()


# 3. Set and check RELEASE_DIR (This is a build directory, CMake will create it)
set(RELEASE_DIR "${CMAKE_CURRENT_BINARY_DIR}/dist")
# CMake's make_directory command in post_build will create this, no need for pre-check here.
# message(STATUS "Release directory will be: ${RELEASE_DIR}") # Optional: for info

# 4. Set and check PACKAGE_DATA_DIR (This is usually a source directory, should exist or be created by custom commands)
set(PACKAGE_DATA_DIR "${CMAKE_SOURCE_DIR}/packages/com.bitmutex.qffgui/data")
if(NOT IS_DIRECTORY "${PACKAGE_DATA_DIR}")
    # You can either create it or error out. For an existing structure, erroring is safer.
    message(FATAL_ERROR "Error: Package data directory not found: ${PACKAGE_DATA_DIR}. Please ensure this directory exists.")
else()
    message(STATUS "Package data directory found at: ${PACKAGE_DATA_DIR}")
endif()


# Create Zip distributable name based on platform
if(CMAKE_SYSTEM_NAME STREQUAL "Windows")
    set(ZIP_NAME "${CMAKE_SOURCE_DIR}/dist.zip")
elseif(CMAKE_SYSTEM_NAME STREQUAL "Linux")
    set(ZIP_NAME "${CMAKE_SOURCE_DIR}/dist_linux.zip")
elseif(CMAKE_SYSTEM_NAME STREQUAL "Darwin")
    set(ZIP_NAME "${CMAKE_SOURCE_DIR}/dist_mac.zip")
else()
    set(ZIP_NAME "${CMAKE_SOURCE_DIR}/dist_unknown.zip")
endif()


if(CMAKE_SYSTEM_NAME STREQUAL "Windows")
        set(INSTALLER_OUTPUT "${CMAKE_SOURCE_DIR}/qff_installer.exe")
else()
        set(INSTALLER_OUTPUT "${CMAKE_SOURCE_DIR}/qff_installer")
endif()

# Define variables for the conditional command based on the platform
if(WIN32)
    # On Windows, define the command to copy the executable with .exe extension
    # REMOVE THE OUTER QUOTES HERE
    set(_COPY_EXE_COMMAND ${CMAKE_COMMAND} -E copy "$<TARGET_FILE:qffgui>" "${RELEASE_DIR}/qffgui.exe")
    set(_COPY_EXE_COMMENT "Copying built exe to release directory (Windows-specific)")
else()
    # On non-Windows, define a no-op command (e.g., just echo a message)
    set(_COPY_EXE_COMMAND_TOOL ${CMAKE_COMMAND})
    set(_COPY_EXE_COMMAND_ARGS -E echo "Skipping Windows-specific exe copy on non-Windows.")
    set(_COPY_EXE_COMMENT "Skipping Windows-specific exe copy")
endif()

# Add post-build commands

#Generate Windows Distributable
add_custom_command(TARGET qffgui POST_BUILD

    # Step 0: Copy Scripts to build dir from project base
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
        "${CMAKE_SOURCE_DIR}/update_helper.py"
        "${CMAKE_SOURCE_DIR}/unzip_ffmpeg.py"
        "$<TARGET_FILE_DIR:qffgui>"
    COMMENT "Copying helper scripts to build output directory"

    # Step 0: Create release directory
    COMMAND ${CMAKE_COMMAND} -E make_directory "${RELEASE_DIR}"

    # Step 0: Copy Scripts to release dir/dist
   COMMAND ${CMAKE_COMMAND} -E copy_if_different
       "${CMAKE_SOURCE_DIR}/update_helper.py"
       "${CMAKE_SOURCE_DIR}/unzip_ffmpeg.py"
       "${RELEASE_DIR}"
   COMMENT "Copying Python script to build output directory"


   # Step 2: Copy built exe to release directory (This step is now conditional)
   if(WIN32)
       COMMAND ${_COPY_EXE_COMMAND} # On Windows, this holds the full command string
       COMMENT ${_COPY_EXE_COMMENT}
   else()
       COMMAND ${_COPY_EXE_COMMAND_TOOL} # On non-Windows, this is just 'cmake'
       ARGS    ${_COPY_EXE_COMMAND_ARGS} # And these are its arguments
       COMMENT ${_COPY_EXE_COMMENT}
   endif()



    # Step 3: Run windeployqt on the copied exe
        if(NOT "${WINDEPLOYQT_EXE}" STREQUAL "") # Only run if WINDEPLOYQT_EXE is not empty
                COMMAND "${WINDEPLOYQT_EXE}" "${RELEASE_DIR}/qffgui.exe"
                COMMENT "Running windeployqt on copied exe"
        else()
                COMMAND ${CMAKE_COMMAND} -E echo "windeployqt skipped: Not Windows or executable not found."
                COMMENT "windeployqt skipped"
        endif()

    # Step 4: Create destination directory in packages folder
    COMMAND ${CMAKE_COMMAND} -E make_directory "${PACKAGE_DATA_DIR}"1

    # Step 5: Copy all contents of release/ to package folder
    COMMAND ${CMAKE_COMMAND} -E copy_directory "${RELEASE_DIR}" "${PACKAGE_DATA_DIR}"

    COMMENT "Deploying with windeployqt and copying release contents to packages/com.bitmutex.qffgui/data"

    # Step 6: Create Zip distributable
    COMMAND ${CMAKE_COMMAND} -E tar "cfv" "${ZIP_NAME}" --format=zip "${RELEASE_DIR}"
    COMMENT "Creating ZIP archive ${ZIP_NAME} from ${RELEASE_DIR}"


        # Step 7: Generate Installer
        COMMAND "${BINARYCREATOR_EXE}"
                -c "${CMAKE_SOURCE_DIR}/config/config.xml"
                -p "${CMAKE_SOURCE_DIR}/packages"
                "${INSTALLER_OUTPUT}"
        COMMENT "Creating installer using Qt Installer Framework from ${BINARYCREATOR_EXE}"

)

include(GNUInstallDirs)
install(TARGETS qffgui
    BUNDLE DESTINATION .
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
)

# Generate the deployment script for the target MyApp.
qt_generate_deploy_app_script(
    TARGET qffgui
    OUTPUT_SCRIPT deploy_script
    NO_UNSUPPORTED_PLATFORM_ERROR
)

# Call the deployment script on "cmake --install".
install(SCRIPT ${deploy_script})

if(QT_VERSION_MAJOR EQUAL 6)
    qt_finalize_executable(qffgui)
endif()

set(CPACK_PACKAGE_NAME qffgui)
set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "My amazing application")
set(CPACK_PACKAGE_VENDOR "My Company")
set(CPACK_PACKAGE_INSTALL_DIRECTORY ${CPACK_PACKAGE_NAME})
set(CPACK_VERBATIM_VARIABLES ON)
set(CPACK_PACKAGING_INSTALL_PREFIX "/opt/qffgui")
set(CPACK_DEBIAN_PACKAGE_MAINTAINER "Manfred Maintainer <mm@example.com>")
set(CPACK_DEBIAN_PACKAGE_DEPENDS libc6 libstdc++6 libgcc-s1)
include(CPack)
